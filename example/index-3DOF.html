<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3-Segment Robot Arm IK</title>
    <style>
        body { margin: 0; font-family: sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 10px;
            color: white;
        }
        .input-group { margin-bottom: 10px; }
        label { display: inline-block; width: 20px; }
        input { width: 60px; }
        button { width: 100%; padding: 8px; margin-top: 5px; }
        #status { margin-top: 10px; font-style: italic; color: #ffcc00; }
    </style>
</head>
<body>
    <div id="ui-container">
        <h4>Target Position</h4>
        <div class="input-group">
            <label for="x-input">X:</label>
            <input type="number" id="x-input" value="5">
        </div>
        <div class="input-group">
            <label for="y-input">Y:</label>
            <input type="number" id="y-input" value="10">
        </div>
        <div class="input-group">
            <label for="z-input">Z:</label>
            <input type="number" id="z-input" value="5">
        </div>
        <button id="move-btn">Move</button>
        <div id="status"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SCENE SETUP ---
        let scene, camera, renderer, controls;
        let arm, targetSphere, targetPosition;
        const segmentLengths = [5, 5, 5];
        const totalArmLength = segmentLengths.reduce((a, b) => a + b, 0);

        const statusEl = document.getElementById('status');

        function init() {
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 15, 20);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Helpers
            const gridHelper = new THREE.GridHelper(50, 50);
            scene.add(gridHelper);
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Robot Arm
            arm = createRobotArm(segmentLengths);
            scene.add(arm.base);

            // Target visualization
            targetPosition = new THREE.Vector3(5, 10, 5);
            const targetGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const targetMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
            targetSphere = new THREE.Mesh(targetGeometry, targetMaterial);
            targetSphere.position.copy(targetPosition);
            scene.add(targetSphere);

            // UI Listeners
            document.getElementById('move-btn').addEventListener('click', onMoveButtonClick);
            window.addEventListener('resize', onWindowResize);
            
            // Initial IK solve
            solveIK(targetPosition);

            animate();
        }

        function createRobotArm(lengths) {
            const armBase = new THREE.Object3D();
            let currentSegment = armBase;

            const segments = [];
            const joints = [];

            for (let i = 0; i < lengths.length; i++) {
                const segmentLength = lengths[i];
                
                // Joint (as a pivot point)
                const joint = new THREE.Object3D();
                joint.position.y = i === 0 ? 0 : lengths[i-1];
                currentSegment.add(joint);

                // Segment visual
                const segmentGeometry = new THREE.CylinderGeometry(0.5, 0.5, segmentLength, 16);
                const segmentMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(0.2, 0.5, 0.8).lerp(new THREE.Color(0.8, 0.8, 0.8), i / lengths.length) });
                const segmentMesh = new THREE.Mesh(segmentGeometry, segmentMaterial);
                segmentMesh.position.y = segmentLength / 2;
                joint.add(segmentMesh);

                // Store references
                segments.push(segmentMesh);
                joints.push(joint);
                
                currentSegment = joint;
            }
            
            // Add an end-effector marker
            const endEffector = new THREE.Object3D();
            endEffector.position.y = lengths[lengths.length - 1];
            currentSegment.add(endEffector);

            return { base: armBase, joints, segments, endEffector };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onMoveButtonClick() {
            const x = parseFloat(document.getElementById('x-input').value);
            const y = parseFloat(document.getElementById('y-input').value);
            const z = parseFloat(document.getElementById('z-input').value);

            if (isNaN(x) || isNaN(y) || isNaN(z)) {
                statusEl.textContent = "Invalid input. Please use numbers.";
                return;
            }
            
            targetPosition.set(x, y, z);
            targetSphere.position.copy(targetPosition);
            
            solveIK(targetPosition);
        }

        // --- INVERSE KINEMATICS (CCD) ---
        function solveIK(target) {
            const targetDistance = target.length();
            if (targetDistance > totalArmLength) {
                statusEl.textContent = "Target is out of reach!";
                
                // Point the fully extended arm towards the target direction
                const direction = target.clone().normalize();
                const yawAngle = Math.atan2(direction.x, direction.z); // Angle for world Y rotation
                
                // Set base rotation (yaw)
                arm.joints[0].quaternion.setFromEuler(new THREE.Euler(0, yawAngle, 0, 'YXZ'));
                
                // Straighten the other joints (pitch = 0)
                arm.joints[1].quaternion.identity();
                arm.joints[2].quaternion.identity();
                return;
            }
            statusEl.textContent = "Target is reachable.";

            const endEffector = arm.endEffector;
            const joints = arm.joints;
            const iterations = 15;
            const tolerance = 0.1;

            const worldToEnd = new THREE.Vector3();
            const worldToJoint = new THREE.Vector3();
            
            for (let iter = 0; iter < iterations; iter++) {
                if (endEffector.getWorldPosition(new THREE.Vector3()).distanceTo(target) < tolerance) {
                    break; // Converged
                }

                for (let i = joints.length - 1; i >= 0; i--) {
                    const joint = joints[i];
                    joint.updateWorldMatrix(true, false); // Ensure world matrix is up-to-date

                    // Get world positions
                    endEffector.getWorldPosition(worldToEnd);
                    joint.getWorldPosition(worldToJoint);
                    
                    // Create world-space vectors from joint to end-effector and to target
                    const worldJointToEnd = new THREE.Vector3().subVectors(worldToEnd, worldToJoint);
                    const worldJointToTarget = new THREE.Vector3().subVectors(target, worldToJoint);

                    // Transform these vectors into the joint's local space to calculate local rotation
                    const jointInverseWorld = joint.getWorldQuaternion(new THREE.Quaternion()).invert();
                    const localJointToEnd = worldJointToEnd.clone().applyQuaternion(jointInverseWorld);
                    const localJointToTarget = worldJointToTarget.clone().applyQuaternion(jointInverseWorld);

                    // Calculate the local rotation needed to align the vectors
                    const localRotation = new THREE.Quaternion().setFromUnitVectors(localJointToEnd.normalize(), localJointToTarget.normalize());
                    
                    // Apply the calculated local rotation to the joint's quaternion
                    joint.quaternion.multiply(localRotation);

                    // --- APPLY CONSTRAINTS ---
                    // Convert to Euler to zero-out unwanted rotations, then convert back.
                    const euler = new THREE.Euler().setFromQuaternion(joint.quaternion, 'YXZ');
                    
                    if (i === 0) { // Base joint: only Y-axis rotation (yaw)
                        euler.x = 0;
                        euler.z = 0;
                    } else { // Hinge joints: only Z-axis rotation (pitch)
                        euler.x = 0;
                        euler.y = 0;
                    }
                    joint.quaternion.setFromEuler(euler);
                }
            }
        }

        init();
    </script>
</body>
</html>
